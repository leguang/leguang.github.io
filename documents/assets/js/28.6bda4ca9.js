(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{192:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"打币系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打币系统","aria-hidden":"true"}},[e._v("#")]),e._v(" 打币系统")]),e._v(" "),a("blockquote",[a("p",[e._v("Author：Leguang")]),e._v(" "),a("p",[e._v("E-Mail："),a("a",{attrs:{href:"mailto:langmanleguang@qq.com"}},[e._v("langmanleguang@qq.com")])])]),e._v(" "),a("p",[e._v("由于blake2b和nacl等算法除了JS，其他平台暂时没有找到合适的实现，因此打币系统暂时不单一依靠java完成，而是Node和 Java 结合的异构系统。Node充当算法工具，Java完成业务。")]),e._v(" "),a("h2",{attrs:{id:"工具api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工具api","aria-hidden":"true"}},[e._v("#")]),e._v(" 工具Api")]),e._v(" "),a("p",[e._v("利用之前的钱包 JS 代码，运行在Node服务里，把钱包里的部分功能通过接口形式暴露，其中包括如下功能：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("种子/助记词--\x3e私钥（生成发送块时，签名需要私钥）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  var accountBytes = utilService.account.generateAccountSecretKeyBytes(this.wallet.seedBytes, index);\n                var accountKeyPair = utilService.account.generateAccountKeyPair(accountBytes);\n                var accountName = utilService.account.getPublicAccountID(accountKeyPair.publicKey);\n")])])])]),e._v(" "),a("li",[a("p",[e._v("生成发送块（其中发送方地址/接收方地址与公钥互转在JS内部完成）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" // 生成发送块信息\n            async generateSend(walletAccount, toAccountID, rawAmount) {\n                var fromAccount = await apiService.accountInfo(walletAccount.id);\n                if (!fromAccount) throw new Error(`Unable to get account information for ${walletAccount.id}`);\n\n                var remaining = new BigNumber(fromAccount.balance).minus(rawAmount);\n                var remainingDecimal = remaining.toString(10);\n                var remainingPadded = remaining.toString(16);\n                while (remainingPadded.length < 32) remainingPadded = '0' + remainingPadded; // Left pad with 0's\n\n                var blockData;\n                var representative = \"mol_3ytentj15q44he4c778317r868wdttwufp96fsccjux4tuqc59ojgrwn6d4w\";\n                var context = blake.blake2bInit(32, null);\n\n                var STATE_BLOCK_PREAMBLE = '0000000000000000000000000000000000000000000000000000000000000006';\n\n                blake.blake2bUpdate(context, utilService.hex.toUint8(STATE_BLOCK_PREAMBLE));\n                blake.blake2bUpdate(context, utilService.hex.toUint8(utilService.account.getAccountPublicKey(\n                    walletAccount.id)));\n                blake.blake2bUpdate(context, utilService.hex.toUint8(fromAccount.frontier));\n                blake.blake2bUpdate(context, utilService.hex.toUint8(utilService.account.getAccountPublicKey(\n                    representative)));\n                blake.blake2bUpdate(context, utilService.hex.toUint8(remainingPadded));\n                blake.blake2bUpdate(context, utilService.hex.toUint8(utilService.account.getAccountPublicKey(\n                    toAccountID)));\n                var hashBytes = blake.blake2bFinal(context);\n\n                var signed = nacl.sign.detached(hashBytes, walletAccount.keyPair.secretKey);\n                var signature = utilService.hex.fromUint8(signed);\n\n                blockData = {\n                    type: 'state',\n                    account: walletAccount.id,\n                    previous: fromAccount.frontier,\n                    representative: representative,\n                    balance: remainingDecimal,\n                    link: utilService.account.getAccountPublicKey(toAccountID),\n                  //  work: await workPoolService.getWork(fromAccount.frontier),\n                    signature: signature,\n                };\n\n                return blockData;\n            },\n")])])])])]),e._v(" "),a("p",[e._v("其中 "),a("code",[e._v("种子--\x3e私钥")]),e._v("这个只需要给出一个在线的静态页面，用户填写种子后地到公钥和私钥，这样就解决了私钥的安全问题，同时也提供了工具给他们，一个静态页面的源码大家都看得到，所以就排除我们偷存私钥的嫌疑。")]),e._v(" "),a("p",[a("img",{attrs:{src:"images/01.png",alt:"01"}})]),e._v(" "),a("h2",{attrs:{id:"打币系统-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打币系统-2","aria-hidden":"true"}},[e._v("#")]),e._v(" 打币系统")]),e._v(" "),a("h3",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程","aria-hidden":"true"}},[e._v("#")]),e._v(" 流程")]),e._v(" "),a("p",[e._v("只需要对外提供一个接口即可，让第三方开发者将发送方地址、对应的私钥、接收方地址、币数量传过来，自己再调用生成发送块的Api，生成一个发送块，然后就可以丢到队列里按支付的那一套流程："),a("code",[e._v("请求前一个块的hash--\x3e申请工作量证明--\x3e添加到生成块中--\x3eprocess--\x3e申请投票--\x3e确认--\x3e回调")]),e._v("  即可。只不过这里稍微要注意一下是打币速度过快可能会让节点拥堵，这个之前有遇到过，所以建议打币系统和支付系统分开，节点也各自不同，不要让第三方开发者联想到两者有什么联系，同时建议不要像支付系统一样，在申请工作量证明那里就process，而是延后一点，以耽误一下时间，避免过快的发送到链上，当然这里需要再讨论和论证一下。")]),e._v(" "),a("h3",{attrs:{id:"安全问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 安全问题")]),e._v(" "),a("p",[e._v("由于这些接口都是在后台运行，因此不存在什么安全问题，只是一个单纯的、特殊的process接口，又由于发送方的地址是由调用方决定的，因此不存在金额对账等烦恼，我们顶多在请求前一个块的hash的时候顺便检测一下是否够发送这笔交易，如果不够给个合理的描述或者异常而已。")]),e._v(" "),a("h3",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 性能问题")]),e._v(" "),a("p",[e._v("如果真的担心Node服务器的性能问题可以考虑用Nginx左一层负载均衡。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("以上这些在理论上是行得通的，希望两至三周时间完成开放平台（前后端）和这个打币系统，至此，整个SDK部分完结。")])])}],!1,null,null,null);t.default=r.exports}}]);